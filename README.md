## https://syntax-quiz.netlify.app

This repo is entirely generated by Claude Code and GitHub Copilot

---

## What is Syntax Quiz?

Syntax Quiz is an interactive, browser-based learning game that helps JavaScript and TypeScript developers practice and sharpen their understanding of language syntax and terminology. The app presents real code snippets with a highlighted region and asks players to identify the correct term for what they see — whether that's a parameter versus an argument, a template literal versus a string, or a discriminated union versus a generic type. The goal is not rote memorisation but genuine conceptual clarity: the kind of precision that makes reading documentation, talking to colleagues, and searching for help dramatically more effective.

The project is built on React 19, TypeScript, and Vite. Syntax highlighting of all code snippets is handled by Shiki, which runs at build time via a custom Vite plugin. Rather than tokenising code on every page load, the plugin pre-processes every snippet during the build and exposes the results as a virtual module. This means highlighting is instant and there is no client-side parsing overhead, keeping the experience snappy even on slower devices.

---

## Question Design and Difficulty Levels

The question bank is organised into three difficulty levels. Level 1 covers the everyday fundamentals — array methods like `.map()` and `.filter()`, the difference between a declaration and an invocation, naming conventions such as SCREAMING_SNAKE_CASE, and basic module syntax. Level 2 moves into intermediate territory: destructuring assignment, closures, hoisting, the event loop, async/await patterns, and error handling. Level 3 tackles advanced TypeScript concepts including generic constraints, mapped types, conditional types, discriminated unions, recursive types, and custom hook conventions.

Each question is narrow and precise by design. Rather than asking broad questions that reward guessing, every question targets a single, unambiguous term. This keeps the cognitive load low per question while building a wide vocabulary across the session. Questions and their answer options are shuffled at the start of each quiz, so replaying a level still feels fresh.

---

## The Feedback Banner

The feedback banner is one of the most deliberate pedagogical choices in the app. After every answer — correct or incorrect — a banner slides in at the bottom of the screen. For a correct answer it turns green; for an incorrect one it turns red; for a skipped question it turns grey. But the colour is almost secondary to the content: every banner includes a plain-English explanation of why the right answer is right.

These explanations are not simply "Yes, that's correct." They address the exact misconceptions that commonly arise. For example, a question about arrow functions explains that arrow functions, lambdas, anonymous functions, and inline functions are related but distinct concepts and should not be used interchangeably. A question about parameters versus arguments spells out that a parameter exists in the function declaration and an argument is what you pass at the call site. This explanation-first approach means players walk away with a corrected mental model rather than just a score.

For correct answers, the banner starts an eight-second countdown and then automatically advances to the next question. This gives players enough time to read the explanation without forcing them to sit through it every time. If they want more time — perhaps to follow the MDN documentation link that appears for each answer — they can tap the pause button to freeze the countdown. If they have read enough and want to move on immediately, a skip button dismisses the banner at once. For incorrect or skipped answers, there is no auto-advance: the player must consciously choose to continue, which gently encourages them to read the explanation before moving on.

On mobile, the feedback banner can also be swiped away to the right. A velocity threshold prevents accidental dismissal from light taps, but a deliberate rightward swipe feels natural and fast.

---

## The Skip Button: No-Pressure Learning

Every question has an "I don't know" button. Pressing it marks the question as missed and triggers the grey feedback banner with the correct answer and explanation, but it does not apply any score penalty beyond resetting the streak to zero — the same consequence as an incorrect answer. This is an intentional choice.

Forcing players to guess when they genuinely have no idea trains guessing, not understanding. Allowing a graceful skip encourages honesty about what you know, surfaces the correct information immediately, and ensures that the question comes back in the retry round so you get another attempt at it after having seen the answer. The lack of a harsh penalty for skipping removes the anxiety around not knowing something, which tends to make people more willing to engage with difficult material.

---

## Hints

Each question supports up to two hints, and their design is graduated rather than all-or-nothing. The first hint eliminates two of the wrong answer options, narrowing the field and making the correct answer more findable through reasoning. The second hint reveals a short explanatory sentence about the concept being tested. This two-stage approach mirrors the Socratic method: rather than immediately handing over the answer, it first tries to help you get there yourself.

Hints do carry a scoring cost: each hint used on a question halves the points you would earn for a correct answer. One hint means 50% of the base points; two hints means 25%. This creates a meaningful trade-off without being punitive — using a hint is always better than giving a wrong answer when the alternative is guessing blind.

---

## Scoring and Streak System

The scoring formula is `BASE_POINTS × (streak + 1) × (0.5 ^ hints_used)`. Base points are 10 per question. The streak multiplier means that a run of consecutive correct answers compounds: the tenth correct answer in a row is worth ten times as much as the first. This creates a natural flow-state incentive: the better you know the material, the more rewarding it feels to stay in the zone. Missing a question or skipping resets the streak to zero, so the risk of breaking a long run adds a small but real tension to each question.

The streak is displayed in the header as a flame icon with a counter. Watching that number grow is a small but effective motivation, and seeing it reset is a concrete signal that something was not as solid as it felt.

---

## Retry Rounds

When a player has worked through all the questions in a level, any questions they answered incorrectly or skipped are collected into a retry round. This second pass resets the hints available on each question and resets the streak to zero, but it gives learners a direct second attempt at the exact concepts they stumbled on. The retry round only ends when every question in it has been answered correctly — there is no way to finish a level while leaving gaps.

This design reflects a mastery-oriented view of learning: the goal is not to finish quickly with a passing grade but to actually understand every concept before moving on. The retry round makes that expectation explicit and concrete without being punishing, because by the time a player reaches it they will have already seen the correct answer and explanation at least once.

---

## Save and Resume

Quiz progress is encoded into a URL query parameter using Base64URL encoding and validated with Zod on load. This means players can save their progress at any point and return later without losing their place, score, or streak — no backend required, no account needed. The save state captures the remaining questions, current score, streak, and which answer options have already been eliminated. A copy-to-clipboard button in the save modal makes it easy to bookmark or share the URL.

---

## Accessibility and Sensory Feedback

The app is built with accessibility as a first-class concern. All interactive elements are keyboard navigable with visible focus rings. A skip-to-content link appears at the top for keyboard and screen reader users. ARIA live regions announce feedback banner content appropriately — assertive for incorrect answers, polite for correct ones — so screen reader users hear the feedback without having to hunt for it.

Page transitions and animations respect the `prefers-reduced-motion` media query: on devices where the user has indicated a preference for reduced motion, animations are disabled entirely. Touch targets meet the 44px minimum recommended for mobile use. The app also provides haptic feedback through the Vibration API — a short 50ms pulse for a correct answer and a distinctive 100-50-100ms pattern for incorrect — giving players a non-visual confirmation of their answer on supported devices. Audio sound effects follow the same pattern, with graceful degradation if the browser prevents playback.

Drag-and-drop is offered as an alternative input method alongside click: players can drag an answer option and drop it onto the code snippet. This supports different interaction preferences and adds a small element of physical engagement to the game, but it is never required — everything is equally accessible by click or tap.

---

## Technology Choices

| Concern | Library |
|---|---|
| UI framework | React 19 |
| Language | TypeScript (strict mode) |
| Build tool | Vite |
| Styling | Tailwind CSS 4 |
| Animations | Motion (Framer Motion) |
| Routing | wouter |
| Drag and drop | dnd-kit |
| Gesture detection | @use-gesture/react |
| Dialog | @base-ui/react |
| Syntax highlighting | Shiki (build-time) |
| Save state validation | Zod |
| Utility functions | es-toolkit |
| Icons | Lucide React |
| E2E testing | Playwright |
| Hosting | Netlify |

The choice of wouter over React Router reflects a preference for minimal dependencies in a single-page app that only has three routes. The choice of @base-ui over Radix or Headless UI reflects similar thinking: it is unstyled, accessible, and brings in only what is needed. Shiki at build time rather than at runtime reflects a commitment to performance on low-end devices.
